<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Planes Flock</title>

    <style>
      * {
        font-family: "Arial", sans-serif;
      }

      html,
      body {
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden;

        background-image: url("/images/through-love.webp");
        background-size: cover;
        background-position: center;
      }

      canvas {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
      }

      h1 {
        position: fixed;
        top: 50%;
        left: 50%;
        z-index: 1;
        transform: translate(-50%, -50%);

        color: white;
        font-size: 1rem;
      }

      * {
        user-select: none;
        webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
      }
    </style>
  </head>
  <body>
    <!-- <h1>PAPER PLANES FLOCK (PPF)</h1> -->

    <canvas></canvas>

    <script src="
https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js
"></script>
    <script src="p5.min.js"></script>
    <script src="Paperplane.js"></script>

    <script>
      let paperplanes = [];
      window.planes = paperplanes;

      let isPressed = false;
      let allowDrawing = true;
      let arrangeWayout = false;
      let animatePlanes = false;

      function evaluateDrawing() {
        // 조건 1. 아래로 돌아오는 진행방향이 존재해서는 안된다.
        const isAnyPlaneGoingDown = _.flatten(paperplanes).some(
          (paperplane) => paperplane.isGoingDown
        );

        if (isAnyPlaneGoingDown) {
          return {
            isValid: false,
            message: "There is a plane going down",
          };
        }

        return {
          isValid: true,
        };
      }

      function resetPaperplanes(paperplanes) {
        paperplanes.forEach((row) => {
          row.forEach((paperplane) => {
            paperplane.reset();
          });
        });
      }

      function setup() {
        // Set canvas size
        const canvas = createCanvas(innerWidth, innerHeight, WEBGL);
        window.addEventListener("resize", () => {
          resizeCanvas(innerWidth, innerHeight);
        });

        const START_X = -width / 2;
        const START_Y = -height / 2;

        // 마우스 프레스 되면 값을 추가한다
        canvas.touchStarted(() => {
          if (!allowDrawing) {
            return;
          }

          isPressed = true;
        });

        canvas.touchEnded(() => {
          const result = evaluateDrawing();

          if (!result.isValid) {
            resetPaperplanes(paperplanes);
          } else {
            // 1. prevent more drawing
            allowDrawing = false;

            // 2. animate the planes
            _.flatten(paperplanes).forEach((paperplane) => {
              console.log(paperplane, "너넨 디졋어");

              // paperplane.animate();
            });
          }

          isPressed = false;

          mouseX = 0;
          mouseY = 0;
        });

        canvas.mouseReleased(() => {
          isPressed = false;

          mouseX = 0;
          mouseY = 0;
        });

        // 한 행에 들어갈 비행기의 갯수만 정하면 나머지는 자동으로 계산된다.
        const NUMBER_OF_COLUMNS = 15;

        const spacing = canvas.width / (NUMBER_OF_COLUMNS - 1);
        const numberOfRows = Math.ceil(canvas.height / spacing);
        const numberOfPlanes = NUMBER_OF_COLUMNS * numberOfRows;

        for (let i = 0; i < numberOfPlanes; i++) {
          const columnIndex = i % NUMBER_OF_COLUMNS;
          const rowIndex = Math.floor(i / NUMBER_OF_COLUMNS);

          const x = START_X + spacing * columnIndex;
          const y = START_Y + spacing * rowIndex;

          const paperplane = new Paperplane(x, y, columnIndex, rowIndex);

          if (!paperplanes[rowIndex]) {
            paperplanes[rowIndex] = [];
          }

          paperplanes[rowIndex][columnIndex] = paperplane;
        }
      }

      function draw() {
        background(255);

        _.flatten(paperplanes).forEach((paperplane) => {
          paperplane.update();
          paperplane.show();
        });

        if (isPressed) {
          window.mouseHoveredDuration += 1;
        }
      }
    </script>
  </body>
</html>
